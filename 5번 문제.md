# 5. 본인이 주력으로 사용하는 언어에서 자료구조와 관련 된 클래스가 내부적으로 어떻게 동작하는지 한 가지 사례를 정하여 작성해 주세요. ex) `ArrayList`, `HashMap` 등등

저는 주로 자바를 사용합니다. `HashMap` 자료구조에 대해서 내부 동작원리를 작성해보고자 합니다.

자바에서 HashMap 은 Map 인터페이스의 구현체로 사용되고 있습니다. 

Map 자료구조는 key - value 를 쌍으로 데이터를 저장하는 구조입니다. 여기서 Hash 가 붙은 이유는 key 에 대한 해시 값을 사용하여 값을 저장하고 조회하기 때문입니다. (key 값으로 조회하게 되면 시간복잡도 O(1) 로 아주 빠르게 조회할 수 있습니다.)

여기서 해시 값이란, `완전한 해시 함수(Perfect Hash Function)` 을 통해 나오는 해시 값을 의미합니다.

자바는 기본 타입과 객체 타입으로 데이터를 관리합니다. 따라서 특정 객체에 대한 해시 값은 완전한 해시 함수를 통해 반환된 해시 값을 이용하게 됩니다.

보통 자바에서는 해시 함수로 hashCode() 를 사용하는데, 이 메소드의 반환 값은 int (32bit) 형이므로 논리적으로 2^32 개의 해시 값을 가질 수 있습니다. 하지만 객체는 2^32 개보다 많을 수 있기 때문에 사실상 완전한 해시 함수를 사용할 수 없다. 또, O(1) 의 조회 시간복잡도를 보장하기 위해서는 원소가 2^32개 인 배열을 모든 HashMap 이 가져야 하므로 메모리 상의 문제도 발생합니다.



따라서 메모리 절약을 위해 실제로 해시 함수는 해시 표현 정수 범위보다 작은 M 개의 원소만 있는 배열을 사용하게 됩니다.

주로 다음과 같은 배열의 갯수를 해시 버킷 인덱스 값으로 사용하게 됩니다.

```java
int index = X.hashCode() % M;
```

이제 특정 객체에 대한 해시 함수를 거친 해시 값은 M 개가 됩니다. 이때 서로 다른 두 객체의 해시 값이 같아지게 되는데, 이를 **충돌 현상(Collision)**이라고 합니다.

이를 대응하기 위한 방법으로 `개방 주소법(Open Addressing)` 과 `분리 연결법(Separate Chaining)` 이 있습니다.

**개방 주소법(Open Addressing)**

- 데이터를 삽입하려는 해시 버킷이 이미 사용중일 경우 인접한 해시 버킷에 삽입합니다.

**분리 연결법(Separate Chaining)**

- 해시 값이 같을 경우 해당 버킷의 배열 인자들이 링크드 리스트로 이루어져 있습니다.

두 방법 모두 최악의 상황에 대한 조회 시간 복잡도는 O(M) 입니다. (해시 충돌 현상이 발생할 때의 케이스 입니다.)



**자바의 HashMap 은 분리 연결법 방식을 선택하고 있습니다.**

- 개방 주소법은 데이터 삭제가 효율적이지 않습니다.
- 데이터 갯수가 많아지게 되면 개방 주소법의 캐시 적중률이 낮아지므로 분리 연결법이 더 빨라지게 됩니다.
- 분리 연결법을 사용하면 보조 해시 함수를 이용하여 해시 충돌 현상을 줄일 수 있습니다.



만약, 객체의 해시 함수 값이 균등 분포 상태라면 get() 을 통한 조회의 기대값은 E(N / M) 입니다.

하지만 Java 8 에서는 이보다 더 나은 E(log N / M) 입니다. 왜냐하면 자바 8 에서는 분리 연결법에서 링크드 리스트가 아닌 트리를 사용하기 때문입니다. (Red-Black Tree 를 사용합니다. -> 트리 순회시 대소 판단 기준은 해시 함수의 값입니다.)



**현재 자바의 HashMap 에서 해시 버킷이 동적으로 확장되고 있습니다.**

해시 버킷의 수가 적다면 메모리 사용을 아낄 수 있지만 해시 충돌로 인해 성능상 손실이 발생할 수 있습니다.

따라서 HashMap 의 key - value 쌍의 데이터 갯수가 일정 갯수가 넘어가면 해시 버킷의 개수를 두배로 증가하고 있습니다.

이때, 버킷 갯수가 두배로 증가할 때마다 모든 키 - 값 데이터를 읽고 새로운 링크드리스트, 혹은 트리를 구성해야 합니다. 

HashMap 생성자에서 초기 해시 버킷 갯수를 지정할 수 있기 때문에 저장 데이터 갯수가 예측가능하다면 위와 같이 불필요한 링크드리스트, 혹은 트리를 새롭게 구성할 필요가 없게 됩니다.



여기서 해시 버킷 개수가 두배로 확장되면 결국 문제가 발생합니다. 해시 버킷의 갯수 M 이 2^k 꼴이 되므로, 결국

```java
int index = X.hashCode() % M;
```

을 통해 계산된 index 는 하위 k 개 비트만 사용하게 되므로, 해시 값을 2^k 꼴로 나누게 되면 해시 충돌이 쉽게 발생하게 됩니다.

이때 **보조 해시 함수**를 사용해야 합니다.



보조 해시 함수는 index 를 균등하게 분포하기 위해 key의 해시값을 변형하여 해시 충돌 가능성을 줄여줍니다.

```java
static final int hash(Object key) {
	int h;
	return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

위와 같이 상위 16비트 값을 XOR 연산하게 되면 균등하게 index 를 분포시킬 수 있습니다.

